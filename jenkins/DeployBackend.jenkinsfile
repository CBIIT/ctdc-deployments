@Library('datacommons-jenkins-shared-library@v1.1') _

def getLabelForEnvironment(environment) {
    if (environment == "stage" || environment == "prod"){
        return "slave-ncias-p3181-c"
    } else {
        return "slave-ncias-d2947-c"
    }
}

pipeline {
    agent {
        node {
            label getLabelForEnvironment(params.Environment)
        }
    }

    parameters {
        string(
            defaultValue: '',
            description: 'The Image to Deploy',
            name: 'ImageTag')

        extendedChoice(
            name: 'Environment',
            defaultValue: 'dev',
            description: 'Choose the environment to deploy to',
            type: 'PT_SINGLE_SELECT',
            value: 'dev,qa,stage,prod')
    }

    options {
        timestamps()
    }

    environment {
        PROGRAM      = "crdc"
        PROJECT      = "ctdc"
        APP          = "backend"
        SLACK_SECRET = "ctdc_slack_url"
        REGION       = "us-east-1"
        ECR_REPO     = "${env.PROGRAM}-${env.PROJECT}-${env.APP}"
        DEPLOY_REPO  = "${env.PROJECT}-deployments"
        IMAGE_TAG    = "${params.ImageTag}"
        ENV          = "${params.Environment}"
        CLUSTER      = "${env.PROGRAM}-${env.ENV}-${env.PROJECT}-ecs"
        SERVICE      = "${env.PROGRAM}-${env.ENV}-${env.PROJECT}-${env.APP}"
    }

    stages {
        stage('checkout') {
            steps {
                checkout([$class: 'GitSCM',
                    branches: [[name: '*/main']],
                    extensions: [
                        [$class: 'SubmoduleOption', recursiveSubmodules: true],
                        [$class: 'RelativeTargetDirectory', relativeTargetDir: 'ctdc-deployments']
                    ],
                    userRemoteConfigs: [[url: "https://github.com/CBIIT/${env.DEPLOY_REPO}"]]
                ])
            }
        }

        stage('Set Environment Variables') {
            steps {
                script {
                    env.SUMO_COLLECTOR_ENDPOINT = sh(label: 'Get Sumo Endpoint', returnStdout: true, script: "aws secretsmanager get-secret-value --region $REGION --secret-id bento/$PROJECT/$ENV --query SecretString --output text | jq -r '.sumo_collector_endpoint' ").trim()
                    env.SUMO_COLLECTOR_TOKEN    = sh(label: 'Get Sumo Token',    returnStdout: true, script: "aws secretsmanager get-secret-value --region $REGION --secret-id bento/$PROJECT/$ENV --query SecretString --output text | jq -r '.sumo_collector_token_${APP}'").trim()
                    env.NEO4J_HOST               = sh(label: 'Get Neo4j Host',     returnStdout: true, script: "aws secretsmanager get-secret-value --region $REGION --secret-id bento/$PROJECT/$ENV --query SecretString --output text | jq -r '.neo4j_ip' ").trim()
                    env.ECR_ACCOUNT              = sh(label: 'Get ECR account',    returnStdout: true, script: "aws secretsmanager get-secret-value --region $REGION --secret-id bento/$PROJECT/$ENV --query SecretString --output text | jq -r '.ecr_account' ").trim()
                    env.REPO_URL                 = "${ECR_ACCOUNT}.dkr.ecr.${REGION}.amazonaws.com/${ECR_REPO}"
                    env.TEMPLATE_FILE            = "ctdc-deployments/aws/${APP}_task.json"
                }
            }
        }

        stage('Add Production Tag') {
            when { expression { ENV == 'prod' } }
            steps {
                script {
                    sh label: 'Docker-Tag', script: '''#!/bin/bash
# Tag image as production if deploying to prod tier
echo "Tagging Image as Production: $ECR_REPO:$IMAGE_TAG"
docker login -u AWS -p $(aws ecr get-login-password --region $REGION) $REPO_URL
docker pull $REPO_URL:$IMAGE_TAG
docker tag $REPO_URL:$IMAGE_TAG $REPO_URL:prod-$IMAGE_TAG
docker push $REPO_URL:prod-$IMAGE_TAG
'''
                    IMAGE_TAG = "prod-${IMAGE_TAG}"
                    echo "updated image tag: $IMAGE_TAG"
                }
            }
        }

        stage('Update Task Definition') {
            steps {
                script {
                    sh label: 'Task-Definition-Update', script: '''#!/usr/bin/env bash
set -euo pipefail

echo "Updating Task Definition to Use: $ECR_REPO:$IMAGE_TAG"
ACCOUNT_ID=$(aws sts get-caller-identity --query Account --output text)
IMAGE_ID="$REPO_URL:$IMAGE_TAG"

# make a fresh copy to preserve original
cp "$TEMPLATE_FILE" updated-task-def.json

# strip JS-style comment blocks to produce valid JSON
sed -i.bak '/\/\*/,/\*\//d' updated-task-def.json

# perform our placeholder substitutions
sed \
  -e "s|{{account_id}}|$ACCOUNT_ID|g" \
  -e "s|{{program}}|$PROGRAM|g" \
  -e "s|{{environment}}|$ENV|g" \
  -e "s|{{project}}|$PROJECT|g" \
  -e "s|{{image_id}}|$IMAGE_ID|g" \
  -e "s|{{image_tag}}|$IMAGE_TAG|g" \
  -e "s|{{sumo_collector_endpoint}}|$SUMO_COLLECTOR_ENDPOINT|g" \
  -e "s|{{sumo_collector_token}}|$SUMO_COLLECTOR_TOKEN|g" \
  -e "s|{{neo4j_host}}|$NEO4J_HOST|g" \
  updated-task-def.json > tmp.json && mv tmp.json updated-task-def.json

# output for debugging
echo '--- rendered JSON ---'
cat updated-task-def.json

echo '--- validation ---'
if ! jq . updated-task-def.json >/dev/null 2>&1; then
  echo "ERROR: Substituted JSON is invalid!" >&2
  exit 1
fi

# register
aws ecs register-task-definition --cli-input-json file://updated-task-def.json
'''
                }
            }
        }

        stage('Update Service') {
            steps {
                script {
                    sh label: 'Service-Update', script: '''#!/bin/bash
# Redeploy Service Using The Latest Task Definition
echo "Updating Service: $SERVICE"
TASK_REVISION=$(aws ecs describe-task-definition --task-definition $SERVICE | egrep "revision" | awk '{print $2}' | sed 's/,//')
aws ecs update-service --cluster $CLUSTER --region $REGION --service $SERVICE --task-definition $SERVICE:$TASK_REVISION --desired-count 1
'''
                }
            }
        }

        stage('verify deployment') {
            steps {
                script {
                    sh label: 'Verify-Deploy', script: '''#!/bin/bash
# wait until the service is stable
aws ecs wait services-stable --cluster $CLUSTER --region $REGION --service $SERVICE
'''
                }
            }
        }
    }

    post {
        always {
            notify(
                secretPath: "notification/slack",
                secretName: "${env.SLACK_SECRET}"
            )
        }
        cleanup { cleanWs() }
    }
}
