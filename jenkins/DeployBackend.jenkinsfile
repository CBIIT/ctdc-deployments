@Library('datacommons-jenkins-shared-library@v1.1') _

def getLabelForEnvironment(environment) {
    if (environment == "stage" || environment == "prod") {
        return "slave-ncias-p3181-c"
    } else {
        return "slave-ncias-d2947-c"
    }
}

pipeline {
    agent {
        node {
            label getLabelForEnvironment(params.Environment)
        }
    }

    parameters {
        string(
            defaultValue: '',
            description: 'The Image to Deploy',
            name: 'ImageTag'
        )
        extendedChoice(
            name: 'Environment',
            defaultValue: 'dev',
            description: 'Choose the environment to deploy to',
            type: 'PT_SINGLE_SELECT',
            value: 'dev,qa,stage,prod'
        )
    }

    options {
        timestamps()
    }

    environment {
        PROGRAM      = "crdc"
        PROJECT      = "ctdc"
        APP          = "backend"
        SLACK_SECRET = "ctdc_slack_url"
        REGION       = "us-east-1"
        ECR_REPO     = "${env.PROGRAM}-${env.PROJECT}-${env.APP}"
        DEPLOY_REPO  = "${env.PROJECT}-deployments"
        IMAGE_TAG    = "${params.ImageTag}"
        ENV          = "${params.Environment}"
        CLUSTER      = "${env.PROGRAM}-${env.ENV}-${env.PROJECT}-ecs"
        SERVICE      = "${env.PROGRAM}-${env.ENV}-${env.PROJECT}-${env.APP}"
        TEMPLATE_FILE = "ctdc-deployments/aws/${APP}_task.json"
    }

    stages {
        stage('checkout') {
            steps {
                checkout([$class: 'GitSCM',
                    branches: [[name: '*/main']],
                    extensions: [
                        [$class: 'SubmoduleOption', recursiveSubmodules: true],
                        [$class: 'RelativeTargetDirectory', relativeTargetDir: 'ctdc-deployments']
                    ],
                    userRemoteConfigs: [[url: "https://github.com/CBIIT/${env.DEPLOY_REPO}"]]
                ])
            }
        }

        stage('Set Environment Variables') {
            steps {
                script {
                    env.SUMO_COLLECTOR_ENDPOINT = sh(
                        label: 'Get Sumo Endpoint',
                        returnStdout: true,
                        script: "aws secretsmanager get-secret-value --region $REGION --secret-id bento/$PROJECT/$ENV --query SecretString --output text | jq -r '.sumo_collector_endpoint'"
                    ).trim()
                    env.SUMO_COLLECTOR_TOKEN = sh(
                        label: 'Get Sumo Token',
                        returnStdout: true,
                        script: "aws secretsmanager get-secret-value --region $REGION --secret-id bento/$PROJECT/$ENV --query SecretString --output text | jq -r '.sumo_collector_token_$APP'"
                    ).trim()
                    env.NEO4J_HOST = sh(
                        label: 'Get Neo4j Host',
                        returnStdout: true,
                        script: "aws secretsmanager get-secret-value --region $REGION --secret-id bento/$PROJECT/$ENV --query SecretString --output text | jq -r '.neo4j_ip'"
                    ).trim()
                    env.ECR_ACCOUNT = sh(
                        label: 'Get ECR account',
                        returnStdout: true,
                        script: "aws secretsmanager get-secret-value --region $REGION --secret-id bento/$PROJECT/$ENV --query SecretString --output text | jq -r '.ecr_account'"
                    ).trim()
                    env.REPO_URL = "${ECR_ACCOUNT}.dkr.ecr.${REGION}.amazonaws.com/${ECR_REPO}"
                }
            }
        }

        stage('Add Production Tag') {
            when {
                expression { env.ENV == 'prod' }
            }
            steps {
                script {
                    sh label: 'Docker-Tag', script: '''
                        echo "Tagging Image as Production: $REPO_URL:$IMAGE_TAG"
                        aws ecr get-login-password --region $REGION | docker login --username AWS --password-stdin $REPO_URL
                        docker pull $REPO_URL:$IMAGE_TAG
                        docker tag $REPO_URL:$IMAGE_TAG $REPO_URL:prod-$IMAGE_TAG
                        docker push $REPO_URL:prod-$IMAGE_TAG
                    '''
                    env.IMAGE_TAG = "prod-${env.IMAGE_TAG}"
                    echo "Updated IMAGE_TAG = ${env.IMAGE_TAG}"
                }
            }
        }

        stage('Update Task Definition') {
            steps {
                script {
                    // Build a fully-populated JSON using jq
                    sh label: 'Render Task Definition', script: """
                        ACCOUNT_ID=\$(aws sts get-caller-identity --query Account --output text)
                        IMAGE_ID="${env.REPO_URL}:${env.IMAGE_TAG}"

                        jq \
                         --arg acct "\$ACCOUNT_ID" \
                         --arg img "\$IMAGE_ID" \
                         --arg envv "${env.ENV}" \
                         --arg prog "${env.PROGRAM}" \
                         --arg proj "${env.PROJECT}" \
                         --arg sumo_ep "${env.SUMO_COLLECTOR_ENDPOINT}" \
                         --arg sumo_tok "${env.SUMO_COLLECTOR_TOKEN}" \
                         --arg neo "${env.NEO4J_HOST}" \
                         '.family = "\($prog)-\($proj)-\(env.APP)" |
                          .containerDefinitions[0].image = $img |
                          .tags = [{key:"environment",value:$envv}] |
                          .containerDefinitions[0].environment += [
                            {name:"SUMO_COLLECTOR_ENDPOINT",value:$sumo_ep},
                            {name:"SUMO_COLLECTOR_TOKEN",value:$sumo_tok},
                            {name:"NEO4J_HOST",value:$neo}
                          ]' \
                         "${TEMPLATE_FILE}" > rendered-task-def.json

                        echo "----- rendered-task-def.json -----"
                        cat rendered-task-def.json
                    """
                    // Register the new task definition
                    sh label: 'Register Task Definition', script: """
                        aws ecs register-task-definition \
                          --region ${env.REGION} \
                          --cli-input-json file://rendered-task-def.json
                    """
                }
            }
        }

        stage('Update Service') {
            steps {
                script {
                    sh label: 'Service-Update', script: """
                        echo "Updating Service: $SERVICE"
                        TASK_REVISION=\$(aws ecs describe-task-definition --task-definition $SERVICE --region $REGION \
                          --query 'taskDefinition.revision' --output text)
                        aws ecs update-service \
                          --cluster $CLUSTER \
                          --region $REGION \
                          --service $SERVICE \
                          --task-definition $SERVICE:\$TASK_REVISION \
                          --desired-count 1
                    """
                }
            }
        }

        stage('Verify Deployment') {
            steps {
                sh label: 'Verify-Deploy', script: """
                    aws ecs wait services-stable \
                      --cluster $CLUSTER \
                      --region $REGION \
                      --service $SERVICE
                """
            }
        }
    }

    post {
        always {
            notify(
                secretPath: "notification/slack",
                secretName: "${env.SLACK_SECRET}"
            )
        }
        cleanup {
            cleanWs()
        }
    }
}
