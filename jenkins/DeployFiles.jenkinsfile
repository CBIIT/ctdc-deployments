@Library('datacommons-jenkins-shared-library@v1.1') _

pipeline {
	agent {
		node {
			label 'slave-ncias-d2947-c'
		}
	}

	parameters {

        string(
            defaultValue: '',
            description: 'The Image to Deploy',
            name: 'ImageTag')

        extendedChoice(
            name: 'Environment',
            defaultValue: 'dev',
            description: 'Choose the environment to deploy to',
            type: 'PT_SINGLE_SELECT',
            value: 'dev,qa,stage,prod')

  }

  options {

	timestamps()

  }

  environment {

	PROJECT      = "ctdc"
	APP          = "files"
	SLACK_SECRET = "ctdc_slack_url"
	REGION       = "us-east-1"
	ECR_REPO     = "${env.PROJECT}-${env.APP}"
	IMAGE_TAG    = "${params.ImageTag}"
	ENV          = "${params.Environment}"
	CLUSTER      = "${env.PROJECT}-${env.ENV}-ecs"
	SERVICE_NAME = "${env.PROJECT}-${env.ENV}-${env.APP}"

  }

  stages{

  	stage('checkout'){

  		steps {

  		checkout([$class: 'GitSCM',
			branches: [[name: '*/main']],
			doGenerateSubmoduleConfigurations: false,
			extensions: [[$class: 'RelativeTargetDirectory',
			relativeTargetDir: 'ctdc-deployments']],
			submoduleCfg: [],
			userRemoteConfigs:
			[[url: 'https://github.com/CBIIT/ctdc-deployments.git']]])

        }

  	}

  	stage('Update Task Definition'){

 		steps {

 			script {

			    if (env.ENV == 'prod') {

                    env.DOMAIN_NAME = "trialcommons.cancer.gov"

                } else {

                    env.DOMAIN_NAME = "trialcommons-${env.ENV}.cancer.gov"
                }

                env.SUMO_COLLECTOR_ENDPOINT = sh(label: 'Get Sumo Endpoint', returnStdout: true, script: "aws secretsmanager get-secret-value --secret-id bento/$PROJECT/$ENV --query SecretString --output text | jq -r '.sumo_collector_endpoint'")
				env.SUMO_COLLECTOR_TOKEN = sh(label: 'Get Sumo Token', returnStdout: true, script: "aws secretsmanager get-secret-value --secret-id bento/$PROJECT/$ENV --query SecretString --output text | jq -r '.sumo_collector_token_files'")

			}
			
			script {

			    sh label: 'Task-Definition-Update', script: '''#!/bin/bash

				# create new revision for $PROJECT-$APP Task Definition
				echo "Updating Task Defintion to Use: $ECR_REPO:$IMAGE_TAG"
				ACCOUNT_ID=$(aws sts get-caller-identity --query "Account" --output text)
				IMAGE_ID="$ACCOUNT_ID.dkr.ecr.$REGION.amazonaws.com/$ECR_REPO:$IMAGE_TAG"
				DATE=$(date '+%m/%d/%Y')

				sed -i "s|{{account_id}}|$ACCOUNT_ID|" ctdc-deployments/aws/files_task.json
				sed -i "s|{{image_id}}|$IMAGE_ID|" ctdc-deployments/aws/files_task.json
				sed -i "s|{{image_tag}}|$IMAGE_TAG|" ctdc-deployments/aws/files_task.json
				sed -i "s|{{environment}}|$ENV|" ctdc-deployments/aws/files_task.json
				sed -i "s|{{project}}|$PROJECT|" ctdc-deployments/aws/files_task.json
				sed -i "s|{{domain_name}}|$DOMAIN_NAME|" ctdc-deployments/aws/files_task.json
				sed -i "s|{{sumo_collector_endpoint}}|$SUMO_COLLECTOR_ENDPOINT|" ctdc-deployments/aws/files_task.json
				sed -i "s|{{sumo_collector_token}}|$SUMO_COLLECTOR_TOKEN|" ctdc-deployments/aws/files_task.json
				sed -i "s|{{date}}|$DATE|" ctdc-deployments/aws/files_task.json

				aws ecs register-task-definition --cli-input-json file://ctdc-deployments/aws/files_task.json

				'''

			}

 		}

  	}

    stage('Update Service'){

 		steps {

 			script {

			    sh label: 'Service-Update', script: '''#!/bin/bash

				# Redeploy Service Using The Latest Task Definition
				echo "Updating Service: $SERVICE_NAME"

				TASK_REVISION=$(aws ecs describe-task-definition --task-definition $SERVICE_NAME | egrep "revision" | awk '{print $2}' | sed 's/,//')
				aws ecs update-service --cluster $CLUSTER --region $REGION --service $SERVICE_NAME --task-definition $SERVICE_NAME:$TASK_REVISION --desired-count 1

				'''

			}

 		}

  	}

	stage('Add Production Tag'){

 		when {

	        expression { 

                ENV == 'dev'

            }

        }

		steps {

 			script {

			    sh label: 'Docker-Tag', script: '''#!/bin/bash

				# Tag image as production if deploying to prod tier
				echo "Tagging Image as Production: $ECR_REPO:$IMAGE_TAG"
				aws_account=$(aws sts get-caller-identity --query "Account" --output text)
				repo_url="$aws_account.dkr.ecr.$REGION.amazonaws.com/$ECR_REPO"

				# login and get manifest
				docker login -u AWS -p $(aws ecr get-login-password --region $REGION) $repo_url
				MANIFEST=$(aws ecr batch-get-image --repository-name $ECR_REPO --image-ids imageTag=$IMAGE_TAG --output json | jq --raw-output --join-output '.images[0].imageManifest')

                # tag as latest and push to ECR
				aws ecr put-image --repository-name $ECR_REPO --image-tag production-$IMAGE_TAG --image-manifest "$MANIFEST"

				'''

			}

 		}

  	}

  }

  post {

    always {

        notify(
            secretPath: "notification/slack",
            secretName: "${env.SLACK_SECRET}"
        ) 

    }

    cleanup {

        cleanWs()

    }

  }

}